<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2024-08-04T00:12:00-03:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Produtividade e algumas recomendações e referências sobre o assunto</title>
    <link rel="alternate" href="http://blog.url.com/2024/08/04/produtividade-e-algumas-recomendacoes-e-referencias-sobre-o-assunto/"/>
    <id>http://blog.url.com/2024/08/04/produtividade-e-algumas-recomendacoes-e-referencias-sobre-o-assunto/</id>
    <published>2024-08-04T00:12:00-03:00</published>
    <updated>2024-08-06T13:45:22-03:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;Produtividade não diz respeito a fazer as coisas mais rápido, mas sim, fazer as coisas de forma consistente e respeitando o tempo e particularidade de cada indivíduo envolvido.&lt;/p&gt;

&lt;p&gt;Existem diversas técnicas para ajudar a nos tornarmos mais produtivos, mas existe algo indispensável no processo que é auto-conhecimento para saber suas virtudes e trabalhar suas oportunidades de melhoria.&lt;/p&gt;

&lt;h2&gt;Conceitos&lt;/h2&gt;

&lt;p&gt;Alguns conceitos que eu acho importante conhecermos.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pt.wikipedia.org/wiki/Kaizen" rel="nofollow"&gt;Kaizen&lt;/a&gt; (evolução contínua)&lt;/li&gt;
&lt;li&gt;Todo List (mantendo listas de tarefas)&lt;/li&gt;
&lt;li&gt;Checklists (para organizar processos)&lt;/li&gt;
&lt;li&gt;WIP Limit (limitar o trabalho em progresso)&lt;/li&gt;
&lt;li&gt;Digital Garden (para compartilhando conhecimentos)&lt;/li&gt;
&lt;li&gt;Matriz de Eisenhower (auxilia na priorização)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Ferramentas&lt;/h2&gt;

&lt;p&gt;E para levar o dia a dia também existem algumas ferramentas que podem nos ajudar (e essas são algumas das que eu gosto de recomendar).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Trello (board kanban para projetos)&lt;/li&gt;
&lt;li&gt;Todoist (para minhas demandas pessoais)&lt;/li&gt;
&lt;li&gt;Google Calendar (compromissos e centralizar eventos)&lt;/li&gt;
&lt;li&gt;Noises (para manter a mente focada)&lt;/li&gt;
&lt;li&gt;IFTTT (uso para integrar tudo ou automatizar processos)&lt;/li&gt;
&lt;li&gt;Logseq (para manter minhas ideias e informações)&lt;/li&gt;
&lt;li&gt;Github (organizar os projetos)&lt;/li&gt;
&lt;li&gt;DuckDuckGo (além de ótimo buscador tem widgets pra várias coisas)&lt;/li&gt;
&lt;li&gt;Cron job scheduler (para agendar várias rotinas mais críticas)&lt;/li&gt;
&lt;li&gt;Greasemonkey userscript (automatizar coisas em web pages)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Métodos&lt;/h2&gt;

&lt;p&gt;Alguns métodos que conheço e costumo usar para as demandas pessoais e profissionais.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GTD (Getting Things Done)&lt;/li&gt;
&lt;li&gt;Pomodoro&lt;/li&gt;
&lt;li&gt;Pair Programming&lt;/li&gt;
&lt;li&gt;Prova de Conceito&lt;/li&gt;
&lt;li&gt;TDD (Test Driven Development)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Tentar Evitar&lt;/h2&gt;

&lt;p&gt;E como não pode faltar, algumas pegadinhas (ciladas Bino) que as vezes podemos passar no trajeto.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FOMO (Fear Of Missing Out)&lt;/li&gt;
&lt;li&gt;Analysis Paralysis&lt;/li&gt;
&lt;li&gt;Overengineering&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Considerações&lt;/h2&gt;

&lt;p&gt;A produtividade depende do ambiente conhecimentos e ponto de vista de cada indivíduo, grupo ou ambiente e por esse motivo as técnicas que funcionam para uma pessoa pode não ser tão eficiente para outro.&lt;/p&gt;

&lt;p&gt;Outro ponto importante é que se trata de um projeto evolutivo e longo de autoconhecimento e uma coisa muito importante é medirmos o que pretendemos melhorar para acompanharmos nossa evolução.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Utilizando o Solid Queue em sua aplicação</title>
    <link rel="alternate" href="http://blog.url.com/2024/08/02/utilizando-o-solid-queue-em-sua-aplicacao/"/>
    <id>http://blog.url.com/2024/08/02/utilizando-o-solid-queue-em-sua-aplicacao/</id>
    <published>2024-08-02T10:25:00-03:00</published>
    <updated>2024-08-06T13:45:22-03:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;A um tempo, o Basecamp lançou uma nova ferramenta de background job compatível com o ActiveJob do Rails.&lt;/p&gt;

&lt;p&gt;Essa ferramenta, mais tarde, foi promovida a uma lib do projeto Rails, para ser uma opção padrão para lidar com tarefas assíncronas em segundo plano.&lt;/p&gt;

&lt;p&gt;O grande diferencial dessa ferramenta é o uso do banco de dados para manter os dados dos Jobs, ao invés das principais opções que fazem uso de in-memory storages como Redis.&lt;/p&gt;

&lt;h2&gt;Instalando o Solid Queue&lt;/h2&gt;

&lt;p&gt;O processo de instalação do Solid Queue é super simple, bastando seguir os passos abaixo.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Adicione a gem ao seu Gemfile&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="n"&gt;gem&lt;/span&gt; &lt;span class="s1"&gt;'solid_queue'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;Instale a gem&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O comando abaixo irá instalar a gem e suas dependências.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;bundle &lt;span class="nb"&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;Crie a tabela no banco de dados&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Como comentei anteriormente, o Solid Queue faz uso do banco de dados para armazenar os Jobs, então precisamos criar a
tabela que irá armazenar esses dados.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;rails solid_queue:install:migrations
rails db:migrate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;Configure o ActiveJob para usar o Solid Queue&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Para que o ActiveJob use o Solid Queue como backend, precisamos configurar o arquivo de configuração do Rails.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="c1"&gt;# config/application.rb&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;Sample&lt;/span&gt;
  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Application&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;Rails&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Application&lt;/span&gt;
    &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;active_job&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;queue_adapter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;:solid_queue&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Criando nosso primeiro Job&lt;/h2&gt;

&lt;p&gt;Vamos supor que temos uma aplicação criada com o comando rails new sample e essa aplicação tenha um model que quando salvo, dispara uma notificação via email rails generate scaffold bookmarks title:string description:text.&lt;/p&gt;

&lt;p&gt;Pensando neste cenário, vamos criar um job que, quando um novo registro for inserido, faça o envio de uma notificação via email.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="c1"&gt;# app/jobs/send_notification_job.rb&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SendNotificationJob&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ApplicationJob&lt;/span&gt;
  &lt;span class="n"&gt;queue_as&lt;/span&gt; &lt;span class="ss"&gt;:default&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;perform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bookmark&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# Aqui você pode chamar o método que envia o email&lt;/span&gt;
    &lt;span class="c1"&gt;# Exemplo: BookmarkMailer.with(bookmark: bookmark).new_bookmark.deliver_now&lt;/span&gt;
    &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"Enviando notificação para &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;bookmark&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;title&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Executando e acompanhando&lt;/h2&gt;

&lt;p&gt;Para que os Jobs sejam executados, precisamos iniciar o processo que irá monitorar a tabela de Jobs e executá-los.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;rails solid_queue:work
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Simplificando o monitoramento com Mission Control&lt;/h2&gt;

&lt;p&gt;Assim como Resque, Sidekiq e outras soluções consolidadas, o Solid Queue também possui um dashboard onde nos podemos acompanhar como está o processo de execução dos Jobs.&lt;/p&gt;

&lt;p&gt;Ele é entregue em uma gem separada, chamada &lt;code&gt;mission_control-jobs&lt;/code&gt;, e podemos instalar ela com os seguintes passos.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 - Adicione a gem ao seu Gemfile&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="n"&gt;gem&lt;/span&gt; &lt;span class="s1"&gt;'mission_control-jobs'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2 - Instale a gem&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;bundle &lt;span class="nb"&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3 - Adicione a rota ao seu arquivo de rotas&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="c1"&gt;# config/routes.rb&lt;/span&gt;

&lt;span class="no"&gt;Rails&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;application&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;routes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;draw&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;mount&lt;/span&gt; &lt;span class="no"&gt;MissionControl&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Jobs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Engine&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s2"&gt;"/mission_control"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4 - Acesse o dashboard&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Agora, basta acessar a rota &lt;code&gt;http://localhost:3000/mission_control&lt;/code&gt; da sua aplicação para visualizar o dashboard.&lt;/p&gt;

&lt;p&gt;&lt;img src="/2024/08/02/utilizando-o-solid-queue-em-sua-aplicacao/queues-multiple.png" alt="Mission Control" /&gt;&lt;/p&gt;

&lt;h2&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O Solid Queue é uma solução simples e bem interessante para lidar com Jobs em background, mas vale lembrar que ela não é a primeira que usa bancos de dados para isso.&lt;/p&gt;

&lt;p&gt;De qualquer forma, estando sob o guarda-chuva do time do Rails e do Basecamp, imagino que podemos esperar uma ótima integração com as APIs e funcionalidades do Rails.&lt;/p&gt;

&lt;p&gt;Fiz alguns testes e quero criar um novo artigo, explicando pontos que observei para melhorar a escalabilidade de soluções Rails usando o Solid Queue.&lt;/p&gt;

&lt;p&gt;Muito obrigado pela visita e nos vemos no próximo post.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Por que Migrei Meu Blog do Jekyll para o Middleman</title>
    <link rel="alternate" href="http://blog.url.com/2024/07/31/por-que-migrei-meu-blog-do-jekyll-para-o-middleman/"/>
    <id>http://blog.url.com/2024/07/31/por-que-migrei-meu-blog-do-jekyll-para-o-middleman/</id>
    <published>2024-07-31T09:59:00-03:00</published>
    <updated>2024-08-06T13:45:22-03:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;Migrar um blog de uma plataforma para outra é uma decisão significativa que pode ser motivada por diversas razões, desde 
melhorias na performance, melhores funcionalidades, etc. Recentemente, decidi migrar meu blog do Jekyll para o 
Middleman, e gostaria de compartilhar as razões que me levaram a fazer essa mudança e quais as minhas percepções sobre
a escolha e o processo.&lt;/p&gt;

&lt;h2&gt;Porque o Jekyll?&lt;/h2&gt;

&lt;p&gt;O Jekyll é uma ferramenta popular para a criação de sites estáticos, talvez seja uma das mais conhecidas e certamente a 
que popularizou essa categoria de ferramentas com a simplicidade em criar sites estáticos, mesmo para que não conhecia a 
linguagem Ruby (na qual a ferramenta foi criada).&lt;/p&gt;

&lt;p&gt;A sintaxe do Liquid, a facilidade de personalização e a comunidade ativa de plugins certamente foram fatores que me 
atraíram para o Jekyll.&lt;/p&gt;

&lt;p&gt;No entanto, ao longo do tempo, comecei a sentir algumas limitações e desafios com o Jekyll que me levaram a considerar
outras opções, como o Middleman que ja conhecia.&lt;/p&gt;

&lt;h2&gt;Porque o Middleman?&lt;/h2&gt;

&lt;p&gt;O Middleman é uma ferramenta de geração de sites estáticos construída em Ruby, que oferece uma abordagem mais flexível e 
personalizável para o desenvolvimento de sites, trazendo principalmente muito do que costumamos usar quando 
desenvolvemos soluções web em ruby.&lt;/p&gt;

&lt;p&gt;As possibilidades nativas e o uso do erb ao inves do liquid, torna tudo mais simples e faz um desenvolvedor 
familiarizado com Ruby se sentir em casa.&lt;/p&gt;

&lt;p&gt;Muitas pessoas podem se perguntar porque não usar outras alternativas como o Gatsby, Hugo, etc. A resposta é simples, o
Middleman é uma ferramenta que já conhecia e que me atende muito bem, então porque mudar?&lt;/p&gt;

&lt;h2&gt;Razões para a migração&lt;/h2&gt;

&lt;h3&gt;1. Queria mais controle e flexibilidade&lt;/h3&gt;

&lt;p&gt;Apesar de gostar muito do Jekyll, sentia que sempre estava &amp;ldquo;lutando&amp;rdquo; para alterar meu conteúdo ou adicionar novas
funcionalidades. &lt;/p&gt;

&lt;p&gt;Diferente disso, o Middleman sempre me ofereceu mais controle e flexibilidade sobre a estrutura e o design dos meus
projetos, facilidade de integrar com qualquer coisa que eu quisesse de forma natural e sem muitas dores de cabeça. &lt;/p&gt;

&lt;h3&gt;2. Sistema de templates&lt;/h3&gt;

&lt;p&gt;O Middleman utiliza o sistema de templates ERB, Haml, Slim, entre outros, o que facilita a criação de layouts complexos 
e reutilizáveis. Isso se traduz em um desenvolvimento mais eficiente e uma manutenção mais simples. &lt;/p&gt;

&lt;p&gt;No Jekyll, embora os templates sejam poderosos, a sintaxe do Liquid pode ser limitada para certos casos de uso que eu 
precisava.&lt;/p&gt;

&lt;h3&gt;3. Ecossistema de plugins&lt;/h3&gt;

&lt;p&gt;O ecossistema de plugins do Middleman é robusto e altamente extensível, tendo praticamente tudo que eu preciso.&lt;/p&gt;

&lt;p&gt;Mesmo se não tiver, acho a facilidade de criar um plugin para o Middleman muito boa. &lt;/p&gt;

&lt;h3&gt;4. Experiência pessoal&lt;/h3&gt;

&lt;p&gt;Trabalhei um bom tempo com projetos frontend usando Middleman e sempre gostei da experiência, então a familiaridade com
a ferramenta foi um fator importante na minha decisão.&lt;/p&gt;

&lt;p&gt;Usar o Middleman para o meu blog me permitiu usar o que eu ja sabia e manter o foco no que eu preciso, que é o conteúdo. &lt;/p&gt;

&lt;h2&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A migração do meu blog do Jekyll para o Middleman foi uma decisão que me trouxe muitos benefícios e melhorias.&lt;/p&gt;

&lt;p&gt;Não estou dizendo que o Jekyll é ruim, pelo contrário, é uma ferramenta incrível e que me ajudou muito, mas o Middleman
sendo uma solução na qual tenho mais familiaridade, me permite ter menos friccção sobre manter ele e mais no conteúdo
que quero compartilhar.&lt;/p&gt;

&lt;p&gt;Não espero que outras pessoas façam a mesma migração, mas espero que minha experiência possa ajudar alguém a tomar uma
decisão informada sobre qual ferramenta usar para o seu blog ou site estático, com base nas suas necessidades.&lt;/p&gt;

&lt;p&gt;No final do dia, o que importa é você usar uma ferramenta que te atenda e não o hype do momento.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Criando um projeto de frontend usando Middleman e TailwindCSS</title>
    <link rel="alternate" href="http://blog.url.com/2024/07/30/criando-um-projeto-de-frontend-usando-middleman-e-tailwindcss/"/>
    <id>http://blog.url.com/2024/07/30/criando-um-projeto-de-frontend-usando-middleman-e-tailwindcss/</id>
    <published>2024-07-29T21:00:00-03:00</published>
    <updated>2024-08-06T13:45:22-03:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;Neste artigo, vamos criar um projeto de frontend usando Middleman e TailwindCSS.&lt;/p&gt;

&lt;h2&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Middleman é um gerador de sites estáticos que permite criar sites usando HTML, CSS e JavaScript. TailwindCSS é um
framework de CSS que facilita a criação de interfaces responsivas e bonitas.&lt;/p&gt;

&lt;h2&gt;Criando um novo projecto&lt;/h2&gt;

&lt;p&gt;Para criar um novo projecto com Middleman, execute o seguinte comando:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;middleman init my_project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Este comando irá criar uma nova pasta chamada &lt;code&gt;my_project&lt;/code&gt; com a estrutura básica de um projecto Middleman.&lt;/p&gt;

&lt;h2&gt;Instalando o TailwindCSS&lt;/h2&gt;

&lt;p&gt;Para instalar o TailwindCSS no seu projecto, execute os seguintes comandos:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;my_project
npm &lt;span class="nb"&gt;install&lt;/span&gt; &lt;span class="nt"&gt;-D&lt;/span&gt; tailwindcss
npx tailwindcss init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Em seguida, adicione o seguinte código ao seu ficheiro &lt;code&gt;tailwind.config.js&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;&lt;span class="cm"&gt;/** @type {import('tailwindcss').Config} */&lt;/span&gt;
&lt;span class="nx"&gt;module&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;exports&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="na"&gt;content&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;./src/**/*.{html,js}&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
  &lt;span class="na"&gt;theme&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="na"&gt;extend&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt;
  &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="na"&gt;plugins&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[],&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Altere o nome do arquivo &lt;code&gt;site.css.scss&lt;/code&gt; para &lt;code&gt;site.css&lt;/code&gt;. e adicione o seguinte código:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight css"&gt;&lt;code&gt;&lt;span class="k"&gt;@tailwind&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;@tailwind&lt;/span&gt; &lt;span class="n"&gt;components&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;@tailwind&lt;/span&gt; &lt;span class="n"&gt;utilities&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Adicionando estilos ao seu projecto&lt;/h2&gt;

&lt;p&gt;Agora que o TailwindCSS está instalado, pode começar a adicionar estilos ao seu projecto. Por exemplo, pode adicionar
um botão com o seguinte código:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight html"&gt;&lt;code&gt;&lt;span class="nt"&gt;&amp;lt;button&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  Button
&lt;span class="nt"&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Compilando os ficheiros CSS&lt;/h2&gt;

&lt;p&gt;Para compilar os ficheiros CSS do TailwindCSS, adicione o seguinte script ao seu ficheiro &lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight json"&gt;&lt;code&gt;&lt;span class="nl"&gt;"scripts"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="nl"&gt;"build"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"tailwindcss build stylesheets/site.css -o .tmp/dist/site.css"&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Depois de adicionar o script, execute o seguinte comando para compilar os ficheiros CSS:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;npm run build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Alterando o config.rb do Middleman&lt;/h2&gt;

&lt;p&gt;Para que o Middleman compile os ficheiros CSS corretamente, adicione o seguinte código ao seu ficheiro &lt;code&gt;config.rb&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="n"&gt;activate&lt;/span&gt; &lt;span class="ss"&gt;:external_pipeline&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="ss"&gt;name: :webpack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="ss"&gt;command: &lt;/span&gt;&lt;span class="n"&gt;build?&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="s2"&gt;"npm run build"&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"npm run start"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="ss"&gt;source: &lt;/span&gt;&lt;span class="s2"&gt;".tmp/dist"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="ss"&gt;latency: &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Neste artigo, criamos um projecto de frontend usando Middleman e TailwindCSS. Espero que este artigo tenha sido útil
example article. You probably want to delete it and write your own articles!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Como eu comecei a gerenciar meu conhecimento usando Logseq</title>
    <link rel="alternate" href="http://blog.url.com/2024/07/01/como-eu-comecei-a-gerenciar-meu-conhecimento-usando-logseq/"/>
    <id>http://blog.url.com/2024/07/01/como-eu-comecei-a-gerenciar-meu-conhecimento-usando-logseq/</id>
    <published>2024-07-01T16:30:00-03:00</published>
    <updated>2024-08-06T16:50:19-03:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;img src="/2024/07/01/como-eu-comecei-a-gerenciar-meu-conhecimento-usando-logseq/banner.png" alt="Logseq" /&gt;&lt;/p&gt;

&lt;h2&gt;Como tudo começou&lt;/h2&gt;

&lt;p&gt;Minha memória não é das melhores para diversas coisas, e minha capacidade de manter a atenção é bastante limitada.&lt;/p&gt;

&lt;p&gt;Sempre que preciso me lembrar de detalhes específicos, torna-se um verdadeiro desafio. Por isso, anotar as coisas
tornou-se essencial para a minha sobrevivência diária.&lt;/p&gt;

&lt;h2&gt;Escolhendo as ferramentas&lt;/h2&gt;

&lt;p&gt;Já experimentei vários métodos e ferramentas para gerenciar meu conhecimento. Tentei usar wikis, Google Docs e Basecamp.&lt;/p&gt;

&lt;p&gt;Depois de muita busca por uma ferramenta e formato que funcionassem bem para mim, resolvi focar no simples e passei a
usar Markdown.&lt;/p&gt;

&lt;p&gt;O uso de arquivos Markdown finalmente começou a fazer sentido para mim, mas ainda precisava de uma ferramenta que me
ajudasse a ser mais produtivo e a organizar melhor minhas ideias.&lt;/p&gt;

&lt;p&gt;Testei algumas excelentes opções open source e gratuitas, mas nenhuma tinha as combinações de funções que eu estava
buscando, até chegar no Obsidian.&lt;/p&gt;

&lt;p&gt;Usei o Obsidian por um tempo, mas sentia que ele me oferecia tantas possibilidades que acabava perdendo o foco.&lt;/p&gt;

&lt;p&gt;Assim como escolhi o Todoist pela sua eficiência e simplicidade, queria algo semelhante para minhas notas. Foi então
que, em um grupo de notas e produtividade, descobri o Logseq, que empresta muitos conceitos do Roam Research.&lt;/p&gt;

&lt;p&gt;Quando resolvi testar o Logseq, fiquei fascinado. Ele tinha exatamente o que eu precisava na medida certa e, mesmo não
sendo perfeito, oferecia as combinações de funções que me permitiam criar notas de forma organizada e com foco.&lt;/p&gt;

&lt;h2&gt;Como organizo minhas notas&lt;/h2&gt;

&lt;p&gt;Costumo usar um modelo de diários diários (daily journals) e adiciono algumas páginas para outros temas que prefiro
separar. Dessa forma, sinto que as coisas ficam mais bem organizadas. Também uso bastante referências e tags, nativas do
Logseq, o que me permite criar consultas (queries) e linkar assuntos para facilitar a pesquisa e a localização quando
necessário.&lt;/p&gt;

&lt;p&gt;Nas minhas notas diárias, costumo ter um espaço para falar sobre aspectos pessoais, como estou me sentindo, e também
sobre aspectos do meu dia, tanto pessoal quanto profissional.&lt;/p&gt;

&lt;h2&gt;Como é o processo&lt;/h2&gt;

&lt;p&gt;Para manter a consistência, tento registrar minhas anotações diariamente à noite, refletindo sobre o meu dia. Aspectos
mais gerais, anoto conforme vão acontecendo. Quando tenho alguma reunião, deixo referências com antecedência para me
preparar com dúvidas ou pontos importantes.&lt;/p&gt;

&lt;p&gt;Também costumo anotar coisas úteis que vou aprendendo e que podem ser úteis no futuro, como comandos, dicas sobre
produtos, curiosidades sobre diversos assuntos, etc.&lt;/p&gt;

&lt;h2&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O hábito de anotar as coisas fez com que eu estivesse mais presente nas reuniões e me permitiu ter um tempo para
refletir sobre os acontecimentos do meu cotidiano. Além disso, tornou-se uma ferramenta indispensável no meu dia a dia,
permitindo que eu recorde pontos importantes de cada evento e revisite sempre que necessário.&lt;/p&gt;

&lt;p&gt;Mesmo sem nunca ter sido fã de diários, escrever e tirar as ideias da cabeça permite que eu passe o dia com a mente mais
leve. A única coisa que gostaria de melhorar é a frequência com que revisito as informações, para refletir sobre os
fatos e tirar ainda mais aprendizados.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Criando um CLI para adicionar tasks no Todoist</title>
    <link rel="alternate" href="http://blog.url.com/2023/05/10/criando-um-cli-para-adicionar-tasks-no-todoist/"/>
    <id>http://blog.url.com/2023/05/10/criando-um-cli-para-adicionar-tasks-no-todoist/</id>
    <published>2023-05-09T21:00:00-03:00</published>
    <updated>2024-08-06T13:45:22-03:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;Sou uma pessoa que funciona muito bem usando todo lists e gosto principalmente de usar ferramentas ou plataformas que permitam ter acesso as minhas tasks sempre que preciso.&lt;/p&gt;

&lt;p&gt;Passei um momento da minha vida testando diversas delas e uma das que mais gostei foi o Google Tasks pela extrema simplicidade. Porém essa simplicidade toda me fez esbarrar em coisas que eu precisava muito e isso fez eu continuar a busca até chegar no Todoist que me atende perfeitamente.&lt;/p&gt;

&lt;h2&gt;Todoist segundo meus critérios&lt;/h2&gt;

&lt;p&gt;É uma ferramenta poderosa e muito produtiva que permite uso diversos lugares, de smartphone até add-on de navegadores.&lt;/p&gt;

&lt;p&gt;Além de tudo conta com várias interações e uma API muito completa e simples de usar.&lt;/p&gt;

&lt;p&gt;A interface dele é super simples e direto ao ponto, mas sem deixar de ser poderosa, contando com lembretes, recorrência, suporte a AI para te ajudar a definir a tarefa e uma sintaxe que permite adicionar due dates em linguagem natural (tipo tomorrow, at Monday 9:00, next week, etc).&lt;/p&gt;

&lt;h2&gt;Então qual o problema?&lt;/h2&gt;

&lt;p&gt;No meu workflow, uso muito o terminal e evito ao máximo &amp;ldquo;sair dele&amp;rdquo; porque sei que sou muito ruim em dividir atenção.&lt;/p&gt;

&lt;p&gt;Isso me fez perceber que conforme o aumento do número ou complexidade das demandas, eu me esquecia de anotar minhas tarefas para serem feita.&lt;/p&gt;

&lt;p&gt;Pode parecer besteira mas se para uma pessoa neurotípica é fácil esquecer algo quando está encarando um momento de stress, imagine uma pessoa TDAH.&lt;/p&gt;

&lt;p&gt;Foi aí que comecei a procurar formar de ter essa forma simples de fazer esse registro das tarefas que precisava sem sair do terminal e chavear o contexto em que estava trabalhando.&lt;/p&gt;

&lt;h2&gt;Buscando alternativas e testando hipóteses&lt;/h2&gt;

&lt;p&gt;Pensando muito e testando algumas ferramentas, várias muito boas mas me fariam não utilizar o Todoist.&lt;/p&gt;

&lt;p&gt;Minha premissa era centralizar ao máximo essa &amp;ldquo;captura&amp;rdquo; das informações do que precisaria fazer e com isso me lembrei de uma solução inteligente que tinha visto em um repositório no Github do Tatsuhiko Miyagawa, um software engineer que acompanho desde que codava mais em Perl.&lt;/p&gt;

&lt;p&gt;Ele acabou criando algo muito próximo do que eu queria, mas que aparentemente utilizava as notificações no sistema operacional para criar esses lembretes.&lt;/p&gt;

&lt;h2&gt;Entendendo a referência para adaptar&lt;/h2&gt;

&lt;p&gt;O link para o script está aqui https://github.com/miyagawa/misc-scripts/blob/master/remind, mas explicando brevemente&amp;hellip;&lt;/p&gt;

&lt;p&gt;O script recebe como entrada uma frase em linguagem natural predefinida, algo como &amp;ldquo;remind me at night about do a code review&amp;rdquo; e usando regular expressions ele divide a sentença em duas partes.&lt;/p&gt;

&lt;p&gt;A primeira diz sobre o tempo em que devo ser lembrado ou alertado e com essa parte ele utiliza uma Ruby gem chamada Chronic, para fazer parsing de texto em linguagem natural para data e hora.&lt;/p&gt;

&lt;p&gt;A segunda parte da sentença e apenas a descrição do que precisa ser feito ou lembrado.&lt;/p&gt;

&lt;p&gt;Com essas duas partes ele executa uma expressão, que faz uma chamada de sistema encadeando dois comandos: o sleep para aguardar o número de segundos até que ele seja alertado e quando o tempo chegar, o pushme que não conheço mas imagino ser um serviço de push notification que vai enviar esse lembrete para o computador ou smartphone.&lt;/p&gt;

&lt;h2&gt;Adaptando e implementando a integração com Todoist&lt;/h2&gt;

&lt;p&gt;Entendendo esses comportamentos, adaptei o código para poder entender também português além de descrições em inglês e implementei o envio para minha conta do Todoist usando integração via API Rest.&lt;/p&gt;

&lt;p&gt;O resultado foi uma ferramenta semelhante, que torna muito mais produtivo para mim anotado minhas tarefas e que centraliza todas as informações onde preciso.&lt;/p&gt;

&lt;p&gt;Agradecimentos especiais, obviamente, ao autor original da ideia e do script que serviu de inspiração. =)&lt;/p&gt;
</content>
  </entry>
</feed>
